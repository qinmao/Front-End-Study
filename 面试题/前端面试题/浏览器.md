# 浏览器 相关问题

## 统计任意一网站有多少种 html 标签
  ```js
    new Set([...document.querySelectorAll('*')].map(n=>n.nodeName)).size
  ```

## 本地存储有哪一些？他们三者有什么区别？
1. localStorage
  - 存储时间：数据持久化存储，除非主动删除，否则数据会一直保存在浏览器中，即使浏览器关闭，数据依然存在。
  - 存储大小：通常可以存储 5MB 左右的数据（不同浏览器可能会有所不同）。
  - 作用域：数据只能在同源（同协议、同域名、同端口）的页面中访问，跨域不可访问。
  - API：使用简单的键值对存取数据，通过 localStorage.setItem(key, value) 存储数据，通过 localStorage.getItem(key) 获取数据。

2. sessionStorage
  - 存储时间：数据在浏览器窗口/标签页会话期间有效，关闭标签页或浏览器时数据会被清除。
  - 存储大小：与 localStorage 相似，通常也可以存储大约 5MB 的数据。
  - 作用域：数据仅在当前窗口或标签页中有效，不同的标签页或浏览器窗口之间不能共享数据。
  - API：使用方法和 localStorage 类似

3. cookies
  - 存储时间：可以设置数据的过期时间，也可以设置为会话级别的 cookie，浏览器关闭时自动删除；如果不设置过期时间，cookie 会在会话结束时失效。
  - 存储大小：每个 cookie 的大小限制为 4KB
  - cookie 是通过 HTTP 请求自动发送到服务器的，因此可以在客户端与服务器之间共享数据。
  - API：操作 cookie 比较繁琐，需要手动设置属性（如过期时间、路径、域名等）。可以通过 document.cookie 来读取和写入 cookies，格式为 key=value。

## url 输入到展现的过程
  - DNS 解析:将域名解析成 IP 地址
  - TCP 连接：TCP 三次握手
  - 发送 HTTP 请求
  - 服务器（web 框架）处理请求并返回 HTTP 报文
  - 浏览器解析渲染页面
  - 断开连接：TCP 四次挥手

## 页面的渲染过程
1. 解析HTML，构建DOM树
2. 解析CSS，生成CSS规则树
3. 合并DOM树和CSS规则，生成render树
4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
5. 绘制render树（paint），绘制页面像素信息

## v8的垃圾回收

## 事件循环
  - 事件循环的机制了解吗？宏任务和微任务的执行顺序是怎样的？

## 浏览器的缓存（结合项目的场景下的使用）
* 缓存：强缓存和协商缓存两种
    - 区别：使用本地缓存时，是否需要向服务器验证本地缓存是否依旧有效，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存
    + 使用缓存注意更新的问题：webpack 提供了 hash
        > hash 构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的 hash 值都会更改。
        - chunkhash 不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。
        - contenthash 由文件内容产生的 hash 值，内容不同产生的 contenthash 值也不一样
    + chunkhash和contenthash的主要应用场景?
        - 在实际在项目中，我们一般会把项目中的 css都抽离出对应的css文件来加以引用。如果我们使用 chunkhash，当我们改了css代码之后，会发现css文件hash 值改变的同时，js文件的hash值也会改变。这时候，contenthash 就派上用场了

    - nodejs 浏览器的缓存方案有服务端返回的响应头决定
      ```js
        // 返回一个强缓存
        res.setHeader('Cache-Control', 'public, max-age=xxx');

        //返回一个协商缓存
        res.setHeader('Cache-Control', 'public, max-age=0');
        res.setHeader('Last-Modified', xxx);
        res.setHeader('ETag', xxx);

       ```
    > 前端缓存时，我们尽可能设置长时间的强缓存，通过文件名加  hash 的方式来做版本更新。在代码分包的时候，应该将一些不常变的公共库独立打包出来，使其能够更持久的缓存

## 应用问题
* 优化性能先做指标监控
  ```js
    const [navigationTiming] = performance.getEntriesByType("navigation");
    if (navigationTiming) {
        console.log(
            "导航耗时:",
            navigationTiming.responseStart - navigationTiming.navigationStart
        );
        console.log(
            "服务器响应耗时:",
            navigationTiming.responseEnd - navigationTiming.requestStart
        );
        // 衡量页面开始呈现并能与用户交互的时间
        console.log(
            "DOM 加载耗时:",
            navigationTiming.domContentLoadedEventEnd -
                navigationTiming.domContentLoadedEventStart
        );
        // 加载所有资源（如图片、样式等）所花费的时间。
        console.log(
            "Load 加载完整耗时:",
            navigationTiming.loadEventEnd - navigationTiming.loadEventStart
        );
    }
    // js 执行的速度检测
    console.time(label) 
    console.timeEnd(label)
  ```
* 页面秒开（首屏显示）从哪些方面优化？
  + 导航耗时高分析: 
    - DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。
    ```html
        <link rel="dns-prefetch" href="//xxx.com">
    ```
    - TCP连接耗时 启用HTTP/2 TCP连接复用
  + 服务器响应耗时高分析：
    - IO:数据库性能，查询
    - 网络带宽
    - 采用缓存技术，http 缓存、中间间缓存 redis
    - 处理性能，提升硬件
  + DOM 加载耗时分析
    - 减少HTML文件大小
    - 异步加载资源：使用 async 或 defer 属性来加载js脚本，避免同步脚本阻塞 DOM 解析。
    - 减少外部资源依赖：CSS、字体文件等，减少请求的数量，资源压缩 技术（如压缩 CSS、JavaScript 文件）来减少资源大小，加速加载
    - 渲染过程中避免频繁操作dom
  + Load 加载完整耗时
    - 懒加载技术：图片、组件