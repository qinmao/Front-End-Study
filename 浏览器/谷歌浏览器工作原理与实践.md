# 浏览器
浏览器中的网络流程、页面渲染过程，js执行流程，以及 Web 安全理论，这些功能是分散在浏览器的各个功能组件中的
通过浏览器的多进程架构的学习，你就可以把这些分散的知识点串起来，组成一张网，从而让自己能站在更高的维度去理解 Web 应用

## 前置知识
[进程线程](../操作系统/linux/进程与线程.md)
[TCP&UDP](../网络协议/tcp&udp.md)

## 宏观角度下的浏览器
* Chrome架构(当前)：仅仅打开了1个页面，为什么有4(至少)个进程？
  + 最新的 Chrome 浏览器有哪些进程：
    - 1个浏览器（Browser）主进程：负责界面显示、用户交互、子进程管理，同时提供存储等功能
    - 1个 GPU 进程：Chrome 刚开始发布是没有 GPU 进程的。为了实现 3D CSS 的效果出的，是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制
    - 1个网络（NetWork）进程：负责页面的网络资源加载
    - 多个渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下
    - 多个插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
  + 当前多进程架构的优缺点
    - 优点：多进程模型提升了浏览器的稳定性、流畅性和安全性
    - 缺点：更高的资源占用、更复杂的体系架构
    >针对当前的问题谷歌提出了面向服务的架构
    >也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统

* 从输入URL到页面展示，这中间发生了什么？
  + 导航流程:用户发出 URL 请求到页面开始解析的这个过程，叫做导航
    - 首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。
    - 然后，在网络进程中发起真正的 URL 请求。网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
    - 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；
    - 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，直接和网络进程建立数据管道；
    - 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。
    - 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。

  + 渲染流程：
    - 构建dom树：渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
    - 样式计算：渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
    - 布局阶段：创建布局树，并计算元素的布局信息。
    - 分层：对布局树进行分层，并生成分层树。
    - 绘制：为每个图层生成绘制列表，并将其提交到合成线程。
    - 分块：合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
    - 光栅化合成：合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
    - 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

* 三个和渲染流水线相关的概念——“重排”“重绘”和“合成”
  + 重排：更新了元素的几何属性,重排需要更新完整的渲染流水线，所以开销也是最大的。
  + 重绘：更新元素的绘制属性，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。
  + 合成：更改既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，例如：使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作

* 如何减少重绘、重排？
  - 使用 class 操作样式，而不是频繁操作 style
  - 避免使用 table 布局
  - 批量 dom 操作，例如 createDocumentFragment，或者使用框架 React
  - Debounce window resize 事件
  - 对 dom 属性的读写要分离
  - will-change: transform 做优化

## v8 工作原理（js执行流程）
* 编译器和解释器：V8是如何执行一段js代码的？
  > 之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言
  > 按语言的执行流程，可以把语言划分为编译型语言和解释型语言。
  + 编译器（Compiler）:
    - 编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。
  + 解释器（Interpreter）:
    - 而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。
  + 编译器和解释器“翻译”代码
  ![编译器和解释器“翻译”代码](./imgs/编译器和解释器.png)
  ![v8执行代码的过程](./imgs/v8执行代码的过程.png)
  + 抽象语法树（AST）
    > 通常，生成 AST 需要经过两个阶段
    - 第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。Babel/ESLint 等应用了ast
    ![分解 token 示意图](./imgs/分解token示意图.png)
    - 第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST
  + 字节码（Bytecode）
    - 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行
  + 即时编译器（JIT）
    - 在 解释器 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）
  + V8是如何执行一段js代码的?
    - 依据 js 代码生成 AST 和执行上下文
    - 再基于 AST 生成字节码
    - 通过解释器执行字节码，编译器来优化编译字节码
    
## 页面循环系统
* 页面线程的循环系统是如何工作的？
  1. 所有同步任务都在主线程上执行，形成一个执行栈（execution contextstack）
  2. 主线程之外，还存在一个"存放任务"的消息队列（把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列）。只要异步任务有了结果，就在"任务队列"之中放置一个事件。
  3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"微任务队列"，放执行栈，开始执行。
  4. 主线程不断重复上面的第三步。主线程的执行过程就是一个 tick。
  
* ![页面循环](./imgs/EventLoop.png)

* 页面使用单线程的缺点：
  > 由于消息队列是“先进先出”的属性，放入队列中的任务，需要等待前面的任务被执行完，才会被执行，导致以下的问题
  + 如何处理高优先级的任务？
    - 在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。
    - 宏任务中主要功能执行完，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务

  + 如何解决单个任务执行时长过久的问题？
    - js 可以通过回调功能来规避这种问题，也就是让要执行的 js 任务滞后执行

* 规范中规定 task 分为两大类:
  + macro task（宏任务）：宿主发起的任务称为宏任务
      - script 
      - setTimeout、setInterval
      - setImmediate 
      - I/O 网络完成
      - UI rendering 事件
  + micro task（微任务）：js引擎发起的任务称为微任务
      - process.nextTick（Node 独有）
      - promise 
      - MutationObserver 异步观测dom的变化
  + 事件循环每一次循环都是一个这样的过程
    <image src='framework/vue/vue2.x/images/event-loop-queue.png'>
    
## 资料来源
* [浏览器工作原理与实践](https://time.geekbang.org/column/intro/216)