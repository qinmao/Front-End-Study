# 浏览器
## 宏观角度下的浏览器
* Chrome架构(当前)：仅仅打开了1个页面，为什么有4(至少)个进程？
  + 进程
    - 一个进程就是一个程序运行的实例，每一个应用程序都至少有一个进程
    - 进程是用来给应用程序体用一个执行的环境，给应用程序分配资源的一个单位

  + 线程
    - 用来执行应用程序中的代码
    - 在一个进程内部，有很多的线程

  + 最新的 Chrome 浏览器有哪些进程：
    - 1个浏览器（Browser）主进程：负责界面显示、用户交互、子进程管理，同时提供存储等功能
    - 1个 GPU 进程：Chrome 刚开始发布是没有 GPU 进程的。为了实现 3D CSS 的效果出的，是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，Chrome 在其多进程架构上引入了 GPU 进程。
    - 1个网络（NetWork）进程：负责页面的网络资源加载
    - 多个渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下
    - 多个插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

  + 当前多进程架构的优缺点
    - 优点：多进程模型提升了浏览器的稳定性、流畅性和安全性
    - 缺点：更高的资源占用、更复杂的体系架构

    >针对当前的问题谷歌提出了面向服务的架构

    >也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统

* TCP协议：如何保证页面文件能被完整送达浏览器？
  + tcp 和 udp 的区别？
    - udp 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。
    + tcp 是一种面向连接的、可靠的、基于字节流的传输层通信协议，
      - 数据包丢失的情况，TCP 提供重传机制；
      - 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件

  + tcp 连接的生命周期：
    - 建立连接阶段：通过“三次握手”来建立客户端和服务器之间的连接。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立
    - 传输数据阶段：接收端在接收到数据包之后，需要发送确认数据包给发送端。当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。
    - 断开连接阶段：数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

* HTTP请求流程：为什么很多站点第二次打开速度会很快？
  - DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的

* 导航流程：从输入URL到页面展示，这中间发生了什么？
  > 输入URL到页面展示需要经历的几个主要的阶段
  + 用户发出 URL 请求到页面开始解析的这个过程，就叫做导航
    - 首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。
    - 然后，在网络进程中发起真正的 URL 请求。
    - 接着，网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
    - 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；
    - 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，直接和网络进程建立数据管道；
    - 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。
    - 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。

* 渲染流程：HTML、CSS、JS 是如何变成页面的？
  - 渲染流程的前三个阶段：DOM 生成、样式计算和布局

+ 完整的渲染流程：
  - 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
  - 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
  - 创建布局树，并计算元素的布局信息。
  - 对布局树进行分层，并生成分层树。
  - 为每个图层生成绘制列表，并将其提交到合成线程。
  - 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
  - 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
  - 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

* 三个和渲染流水线相关的概念——“重排”“重绘”和“合成”
  + 重排：更新了元素的几何属性,重排需要更新完整的渲染流水线，所以开销也是最大的。
  + 重绘：更新元素的绘制属性，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。
  + 合成：更改既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，例如：使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作

* 如何减少重绘、重排？
  - 使用 class 操作样式，而不是频繁操作 style
  - 避免使用 table 布局
  - 批量 dom 操作，例如 createDocumentFragment，或者使用框架 React
  - Debounce window resize 事件
  - 对 dom 属性的读写要分离
  - will-change: transform 做优化
## v8 工作原理
* 编译器和解释器：V8是如何执行一段js代码的？
  > 之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言
  > 按语言的执行流程，可以把语言划分为编译型语言和解释型语言。
  + 编译器（Compiler）:
    - 编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。
  + 解释器（Interpreter）:
    - 而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。
  + 编译器和解释器“翻译”代码
  ![编译器和解释器“翻译”代码](./imgs/编译器和解释器.png)
  ![v8执行代码的过程](./imgs/v8执行代码的过程.png)
  + 抽象语法树（AST）
   > 通常，生成 AST 需要经过两个阶段
   - 第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。Babel/ESLint 等应用了ast
    ![分解 token 示意图](./imgs/分解token示意图.png)
    - 第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST
  + 字节码（Bytecode）
    - 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行
  + 即时编译器（JIT）
    - 在 解释器 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）
  + V8是如何执行一段js代码的?
    - 依据 js 代码生成 AST 和执行上下文
    - 再基于 AST 生成字节码
    - 通过解释器执行字节码，编译器来优化编译字节码
## 页面循环系统（重要）
* 页面线程的循环系统是如何工作的？
  1. 所有同步任务都在主线程上执行，形成一个执行栈（execution contextstack）
  2. 主线程之外，还存在一个"存放任务"的消息队列（把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列）。只要异步任务有了结果，就在"任务队列"之中放置一个事件。
  3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，放执行栈，开始执行。
  4. 主线程不断重复上面的第三步。主线程的执行过程就是一个 tick。
  
* ![页面循环](./imgs/EventLoop.png)

* 页面使用单线程的缺点：
  > 由于消息队列是“先进先出”的属性，放入队列中的任务，需要等待前面的任务被执行完，才会被执行，导致以下的问题
  + 如何处理高优先级的任务？
    - 在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。
    - 宏任务中主要功能执行完，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务

  + 如何解决单个任务执行时长过久的问题？
    - js 可以通过回调功能来规避这种问题，也就是让要执行的 js 任务滞后执行

* 规范中规定 task 分为两大类:
  + macro task（宏任务）：宿主发起的任务称为宏任务
      - script 
      - setTimeout 
      - setInterval
      - setImmediate 
      - I/O 
      - UI rendering

  + micro task（微任务）：js引擎发起的任务称为微任务
      - process.nextTick（Node 独有）
      - promise 
      - MutationObserver 异步观测dom的变化
   
  + 事件循环每一次循环都是一个这样的过程
    <image src='framework/vue/vue2.x/images/event-loop-queue.png'>
    
* js 引擎是如何实现 async/await 的？
  > async/await 使用了 Generator 和 Promise 两种技术

  + 什么是生成器函数?
    - 是一个带星号函数，而且是可以暂停执行和恢复执行的
    ```js
    function* genDemo() {
      console.log("开始执行第一段")
      yield 'generator 2'

      console.log("开始执行第二段")
      yield 'generator 2'

      console.log("开始执行第三段")
      yield 'generator 2'

      console.log("执行结束")
      return 'generator 2'
    }
    console.log('main 0')
    let gen = genDemo()
    console.log(gen.next().value)
    console.log('main 1')
    console.log(gen.next().value)
    console.log('main 2')
    console.log(gen.next().value)
    console.log('main 3')
    console.log(gen.next().value)
    console.log('main 4')
    ```
    - 要搞懂函数为何能暂停和恢复，要了解协程的概念
  + 协程:
    - 可把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程
    - 协程不是被操作系统内核所管理，完全由程序所控制，不会像线程切换那样消耗资源
## 浏览器中的页面
* js 如何影响dom 树构建的？
  + DOM 树如何生成？
    - 渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构
    - HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。
    - 第一个阶段，通过分词器将字节流转换为 Token
    - 后续的第二个和第三个阶段是同步进行的，将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中
## 安全
* [浏览器安全](./浏览器安全.md)
## 资料来源
* [浏览器工作原理与实践](https://time.geekbang.org/column/intro/216)