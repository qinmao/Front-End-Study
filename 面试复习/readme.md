# 面试（基础为重）
> 重点要知道如何组织语言去描述
## 自我介绍（结合项目、技术）
* 工作经历：结合简历
* 用到的技术：框架Vue + 小程序 + 小游戏(尝试)+ h5 + 跨平台 elctron 客户端 + nodejs

## 其他问题
* 面试最后想问的问题（可以问题的一些问题）？
    - 公司做的行业在同类中大概处于什么位置？
    - 公司的研发(要工作的部门)有多少人，大概现在用的技术？
    - 发薪日期？

## 基础
* [js基础](js/js基础.md)
* [js简单算法](js/js简单算法.md)
* [promise](js/promise.md)

## css
* 实现图片自适应宽高
* 

## 浏览器
* url 输入到展现的过程
    - DNS 解析:将域名解析成 IP 地址
    - TCP 连接：TCP 三次握手
    - 发送 HTTP 请求
    - 服务器（web 框架）处理请求并返回 HTTP 报文
    - 浏览器解析渲染页面
    - 断开连接：TCP 四次挥手

* 页面的渲染过程
    1. 解析HTML，构建DOM树
    2. 解析CSS，生成CSS规则树
    3. 合并DOM树和CSS规则，生成render树
    4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
    5. 绘制render树（paint），绘制页面像素信息

* v8的垃圾回收

* 事件循环
  - 事件循环的机制了解吗？宏任务和微任务的执行顺序是怎样的？

* 浏览器的缓存结合项目的场景下的使用

## 框架原理与应用(vue)
* 如何理解 mvvm
  - mvvm 是mode-view-viewModel 的缩写
  - mode 代表数据模型，在这里定义数据的修改和操作的业务逻辑
  - view 代表ui 组件，负责把数据模型转换成ui展示出来
  - viewModel 监听数据模型的变化，控制 ui 显示，起到连接mode view
  > viewModel 通过双向数据绑定把 mode 和 view 连接起来，mode view 之间的数据同步是自动的，所有我们不需要操作 dom ,只要关注数据的业务逻辑处理

* vue里面的虚拟dom是怎么回事？
  - 用对象来描述dom的层级关系
  - 跨平台、性能优化(diff算法)

* vue双向绑定

* vue2|vue3 响应式原理(Object.defineProperty,proxy)
  - Proxy可以直接监听对象而非属性
  - Proxy可以直接监听数组的变化
  - 监听对象属性的变化，属性的增减无法监听

* 依赖收集和派发更新
  - 收集目的：为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理，我们把这个过程叫派发更新
  - 派发更新：就是数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 watcher，都触发它们的 update 过程，这个过程又利用了队列做了进一步优化，在 nextTick 后执行所有 watcher 的 run，最后执行它们的回调函数

* vue 异步更新 dom 是包装成宏任务还是微任务为什么？
  + 分析如下：
    - setTimeout 是一个宏任务，所以推入了宏任务队列
    - 由于 script 也是一个宏任务，也会被放入队列，由于该队列是一个一个执行的，所以本次循环，setTimeout 中不会被渲染，下次循环执行
    - 如果异步更新包装在 micro task 中，队列中先执行 script ，微任务是一对对执行的，所以 Promise 在本次循环被执行了，也就是渲染了

* Vue 父子组件生命周期钩子函数执行顺序
  - 父beforeCreate ->父created ->父beforeMount ->子beforeCreate ->子created ->子beforeMount ->子mounted ->父mounted

* 组件间的通信方式
  - prop
  - emit/on 事件触发
  - provide、inject（vue3）
  - vuex

* Vue computed 和 watch 在什么场景下使用
  - computed 依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。
  - 基于当前自己值得变化来做业务处理（高耗时操作）

* v-for key 值的作用（key要唯一标识的值来处理）
  - 使用 v-for 更新已渲染的元素列表时,默认用就地复用策略。列表数据修改的时候,他会根据key值去判断某个值是否修改：如果修改,则重新渲染这一项;否则复用之前的dom，仅修改value值。

* vue-router的原理
  - 哈希模式：利用了 window 可以监听 hashchange 事件，url 中的哈希值（#后面的值）如果有变化，前端可以做到监听
  - history模式 监听 popstate 事件 历史栈信息变化,变化时重新渲染  pushState 与 replaceState,作用就是可以将url替换并且不刷新页面

* 如何抽取组件，封装组件要考虑哪些问题？
  - props 属性中添加验证规则：
  - 不要依赖 vuex 传参
  - 预留一些 slot
  - 样式值通过变量来设置


## http协议
* 常用的状态码
    + 1xx: 提示信息，表示协议处理的中间状态，需要后续操作
    + 2xx 请求成功，报文收到并被正确处理
        - 200 请求成功
    + 3xx 重定向，资源位置发生变动，需要客户端重新发请求
        - 301&302：永久性与临时性跳转。（重要）
        - 304:客户端缓存没更新（重要）
    + 4xx 客户端请求错误
        - 403: 无权限
        - 404: 请求的页面不存在
    + 5xx 服务端错误
        - 500 服务端错误
        - 503 服务端暂时错误，稍后再试
* HTTP协议（超文本传输协议）
* 1.0 协议缺陷:
   - 无法复用链接，完成即断开，重新慢启动和 TCP 3次握手
   - head of line blocking: 对头阻塞，导致请求之间互相影响
* 1.1 改进:
    - 长连接(默认 keep-alive)，复用
    - host 字段指定对应的虚拟站点
    * 新增功能:
        - 断点续传
        - 身份认证
        - 状态管理
        + cache 缓存
            - Cache-Control
            - Expires
            - Last-Modified
            - Etag
* 2.0:
    - 多路复用
    - 二进制分帧层: 应用层和传输层之间
    - 首部压缩
    - 服务端推送
* 3.0 

## 性能优化
* [防抖、节流](性能优化/防抖节流.html)

## 工程化
## webpack 面试题
* webpack 打包过程
* webpack 热更新原理
* 在项目构建中做了哪些优化？
## vite

## 综合题
* [项目的难点与解决](综合题/项目的难点与解决.md)


